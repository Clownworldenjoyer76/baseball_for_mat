name: Audit Unused Files
on:
  workflow_dispatch:

permissions:
  contents: write

jobs:
  audit:
    runs-on: ubuntu-latest
    env:
      TZ: America/New_York
    steps:
      - name: Checkout (current branch)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Ensure /summaries exists
        run: |
          set -euo pipefail
          mkdir -p summaries/archive
          touch summaries/.gitkeep summaries/archive/.gitkeep

      - name: Cross-reference /scripts vs workflows (robust)
        run: |
          set -euo pipefail
          python - <<'PY'
          import pathlib, re, csv, os

          ROOT = pathlib.Path(".")
          SCRIPTS_DIR = ROOT / "scripts"
          WF_DIR = ROOT / ".github" / "workflows"
          ACT_DIR = ROOT / ".github" / "actions"   # local composite actions
          OUT_DIR = ROOT / "summaries" / "archive"
          OUT_DIR.mkdir(parents=True, exist_ok=True)
          OUT_TXT = OUT_DIR / "unused_scripts_in_workflows.txt"
          OUT_CSV = OUT_DIR / "unused_scripts_in_workflows.csv"

          # 1) Collect scan text from workflows + local composite actions (action.yml/action.yaml)
          texts = []
          def read_all_texts(base: pathlib.Path, patterns):
              if not base.exists():
                  return
              for pat in patterns:
                  for p in base.rglob(pat):
                      try:
                          texts.append(p.read_text(errors="ignore"))
                      except Exception:
                          pass

          read_all_texts(WF_DIR, ["*.yml","*.yaml"])
          read_all_texts(ACT_DIR, ["action.yml","action.yaml","**/*.yml","**/*.yaml"])
          joined = "\n".join(texts)

          # Normalize once for broad substring checks
          norm = joined.replace("\r","")
          # Allow quick Windows-style search too (we'll generate both forms per script)
          # 2) Build the candidate script list
          #    Consider typical script filetypes + executables without extension
          exts = {".py",".sh",".bash",".zsh",".ps1",".cmd",".bat",".js"}
          candidates = []
          if SCRIPTS_DIR.exists():
              for p in SCRIPTS_DIR.rglob("*"):
                  if p.is_file():
                      if p.suffix in exts or (p.stat().st_mode & 0o111):
                          candidates.append(p)

          # 3) Precompute module-call references from "-m scripts.foo[.bar][:entry]"
          #    Accept python/py/uv/poetry/pipenv/pipx variants
          mod_pat = re.compile(
              r"""(?x)
              (?:^|\s)
              (?:python(?:3)?|py|uv\s+run|poetry\s+run|pipenv\s+run|pipx\s+run)
              \s+-m\s+
              (scripts(?:\.[A-Za-z0-9_]+)+)      # module path
              (?::[A-Za-z0-9_]+)?                # optional :entry
              (?:\s|$)
              """,
              re.IGNORECASE
          )
          module_refs = set()
          for m in mod_pat.finditer(norm):
              mod = m.group(1)
              module_refs.add((mod.replace(".","/") + ".py").lower())

          # 4) For each script, check multiple reference styles
          unused = []
          rows = [("path","referenced_in_workflows","hit_type")]

          def any_in(text, needles):
              t = text
              for n in needles:
                  if n and n in t:
                      return n
              return ""

          for p in sorted(candidates):
              rel = p.as_posix()                             # scripts/foo/bar.py
              rel_l = rel.lower()

              # Windows-ish and common variants
              win_rel = rel.replace("/", "\\")
              dot_rel = f"./{rel}"
              dot_win = f".\\{win_rel}"

              # Quoted variants commonly seen in YAML
              quoted = [f"'{rel}'", f"\"{rel}\"", f"'{dot_rel}'", f"\"{dot_rel}\"",
                        f"'{win_rel}'", f"\"{win_rel}\"", f"'{dot_win}'", f"\"{dot_win}\""]

              # Basename-only reference (rarely reliable; keep as fallback)
              base = p.name
              base_win = base.replace("/", "\\")  # usually same

              # Check 1: direct path mention in any shell/pwsh run
              hit = any_in(norm.lower(), [
                  rel_l, dot_rel.lower(),
                  win_rel.lower(), dot_win.lower(),
                  *[q.lower() for q in quoted]
              ])
              hit_type = ""
              if hit:
                  hit_type = "direct-path"

              # Check 2: python -m scripts.pkg[.sub][:entry]
              if not hit and p.suffix == ".py":
                  if rel_l in module_refs:
                      hit = rel
                      hit_type = "python -m"

              # Check 3: invoked via sh/bash/source style (". scripts/foo.sh" or "source scripts/foo.sh")
              if not hit and p.suffix in {".sh",".bash",".zsh"}:
                  shell_needles = [
                      f". {rel}".lower(), f"source {rel}".lower(),
                      f". {dot_rel}".lower(), f"source {dot_rel}".lower(),
                      f". {win_rel}".lower(), f"source {win_rel}".lower()
                  ]
                  hit2 = any_in(norm.lower(), shell_needles)
                  if hit2:
                      hit = hit2
                      hit_type = "shell-source"

              # Check 4: powershell -File scripts\foo.ps1
              if not hit and p.suffix == ".ps1":
                  ps_needles = [
                      f"powershell -file {win_rel}".lower(),
                      f"pwsh -file {win_rel}".lower(),
                      f"powershell -file {rel}".lower(),
                      f"pwsh -file {rel}".lower()
                  ]
                  hit3 = any_in(norm.lower(), ps_needles)
                  if hit3:
                      hit = hit3
                      hit_type = "pwsh-file"

              # Optional fallback: basename match next to python/bash/node (reduces some false negatives,
              # but keep as last resort to avoid false positives)
              if not hit:
                  fallback_needles = [
                      f"python {base}".lower(), f"python3 {base}".lower(),
                      f"py {base}".lower(), f"uv run {base}".lower(),
                      f"poetry run {base}".lower(), f"pipenv run {base}".lower(),
                      f"bash {base}".lower(), f"sh {base}".lower(),
                      f"./{base}".lower(), base.lower()
                  ]
                  hit4 = any_in(norm.lower(), fallback_needles)
                  if hit4:
                      hit = hit4
                      hit_type = "basename-fallback"

              used = bool(hit)
              rows.append((rel, "YES" if used else "NO", hit_type))
              if not used:
                  unused.append(rel)

          with OUT_TXT.open("w") as f:
              for u in unused:
                  f.write(u + "\n")

          with OUT_CSV.open("w", newline="") as f:
              csv.writer(f).writerows(rows)
          PY

      - name: Upload results (artifact)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: unused-scripts-report
          path: |
            summaries/archive/unused_scripts_in_workflows.txt
            summaries/archive/unused_scripts_in_workflows.csv

      - name: Commit summaries to repo
        if: always()
        run: |
          set -euo pipefail
          BRANCH="${GITHUB_HEAD_REF:-${GITHUB_REF_NAME:-$(git rev-parse --abbrev-ref HEAD)}}"
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git checkout "$BRANCH"
          git pull --ff-only origin "$BRANCH" || true
          git add summaries/.gitkeep summaries/archive/.gitkeep \
                  summaries/archive/unused_scripts_in_workflows.txt \
                  summaries/archive/unused_scripts_in_workflows.csv
          git diff --cached --quiet || git commit -m "chore: update unused scripts report"
          git push origin "$BRANCH" || echo "::warning::Push blocked by branch protections; artifacts still uploaded."

      - name: Job Summary
        if: always()
        run: |
          echo "## Scripts in /scripts not referenced by workflows" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ -s summaries/archive/unused_scripts_in_workflows.txt ]; then
            COUNT=$(wc -l < summaries/archive/unused_scripts_in_workflows.txt | tr -d ' ')
            echo "**Count:** $COUNT" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            while read -r line; do
              echo "- \`$line\`" >> $GITHUB_STEP_SUMMARY
            done < summaries/archive/unused_scripts_in_workflows.txt
          else
            echo "No unused scripts found." >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**CSV:** \`summaries/archive/unused_scripts_in_workflows.csv\`" >> $GITHUB_STEP_SUMMARY
